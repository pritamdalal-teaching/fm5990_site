---
title: "Data"
output: html_document
---

This page will contain that data that we use for in-class examples.

Along with the data, I will post exercises for you to complete as a way to practice programming and explore the data.  I won't necessarily go over all of techniques required, so if you don't understand something you may have to use Google. 

Google is your friend.

&nbsp;

### Options Intro

[Options Intro](data_options_intro.csv) - this is a small sample of the Delta Neutral historical options data.  It is end-of-day prices of all the out-of-the-money options for several liquid index ETFs, for one particular expiration, on one particular trading day.

**Exercises:**

1. Read in this data set using `readr::read_csv()`.  Load it into a dataframe called `df_options_intro`.

1. Prove to yourself that this code will work weather you use `readr::read_csv()` or simply `read_csv()`.  Why might you want to use one versus the other?

1. Use `$` notation to grab the `strike` column and print it to the console.  Do the same for `implied_vol` as well as `ask_price`.

1. Use `nrow()` to determine how many rows are in `df_options_intro`.

1. Take a look at `df_options_intro` using `View()`.  Confirm that `nrow()` produced the correct value.  

1. What is the expiration date of all the options?  Which date are these prices from?

1. Use `dplyr::distinct()` to determine how many different underlyings are represented in the data.  What are they?

1. Use `dplyr::filter()` along with variable assignment `<-` to create four sub-dataframes, each of which consists of all of the options for one underlying.  Call these dataframes `df_SPY`, `df_QQQ`, `df_IWM`, `df_DIA`.  (For each iteration, type out the code from scratch. This will be good typing practice that will make you more efficient in the future.)

1. For each of the underlyings, use `ggplot2::qplot()` to create a line graph with `strike` on the x-axis and `implied_vol` on the y-axis.

1. What is the relationship between `strike` and `implied_vol` for these underlyings?

1. Let's break down `df_SPY` a little further.  Using `dplyr::filter()` create two sub-dataframes, one consisting of all the puts and one consisting of all the calls.  Label them `df_SPY_puts` and `df_SPY_calls`, respectively.

1. How many puts are there? How many calls are there?  What are there so many more puts? (Hint: remember that options are insurance contracts and that SPY is an ETF that tracks the S&P 500.)

1. For both `df_SPY_calls` and `df_SPY_puts` create a graph with `strike` on x-axis and `bid_price`.  

1. Based on the graphs you created above: for puts, what is the relationship between strike and price, assuming we hold the price of the underlying fixed?  How about for calls? 


&nbsp;


### OCC Options Volume

[OCC Volume Report](data_occ_201808.csv) - this is a volume report generated by the OCC for August 2018.  This data is freely available on the OCC website.

[ETF List](data_etf_list.csv) - this is a comprehensive list of ETFs I found on the internet; we will use it to assist our analysis.

[Script Outline](exercise_02_occ_top_100_etfs_outline.R) - here is an outline of an R script that you can follow.


**Exercises:**
The purpose of this set of exercises is to perform a bit more volume analysis on the OCC report that we have been working with in class.  The completion of this exercise set should result in a script that can be run all at once.  Feel free to download the attached .R file which has the outline of a script mapped out for you.

1. What should be at the top of most of the scripts you write?

1. Read in both CSV files into dataframes.  Call them `df_occ` and `df_etfs`.

1. With `df_occ`, create a monthly volume report grouping by underlying.  Call the report `df_monthly_volume`.  What is a convenient way to look at this report?

1. **Non-Programming:** Google the following ticker symbol pairs: *SPY* vs *SPX*; *VXX* vs *VIX*.  How are the pairs similar? How are the pairs different?

1. Examine the `segment` column of `df_etfs`.  How can we use this column to identify the volatility-related funds?

1. Notice that the `segment` column of `df_etfs` has uppercase and lowercase letters. Let's convert this to all lower case with `base::tolower()` in conjunction with the cash-money notation. (Hint: we did something similar for the dates column of the OCC volume data in the `dplyr` volume analysis tutorial.)


1. **Context:** In the options backtesting that we are eventually going to do, I want to focus on ETFs, but I want to exclude all volatility related ETFs because they are harder to work with.  More specifically, let's limit our eventual trading universe to the top 100 most liquid ETFs thats are *not* volatility related.

1. In order to do the above, let's first isolate the volatility ETFs into a separate dataframe.  Call it `df_vol_etfs`. Use `dplyr::filter()` with `stringr::str_detect()` as its argument - you will probably need to Google around a bit to figure out how to do this.

1. Now, create a separate dataframe called `df_top_100` that contains the top 100 most liquid non-volatility ETFs.  My solution consists of two uses of `dplyr::filter()`, and one use of each of `dplyr::top_n()` and `dplyr::arrange()`.

1. How many distinct `segments` are represented by the `df_top_100` symbols?

1. **Open-Ended Bonus:** come up with a way to group this distinct segments.   Aim for 5-10 groupings.