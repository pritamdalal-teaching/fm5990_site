---
title: "Tutorial 07 - Functions and Interation"
author: "Pritam Dalal"
output: 
  html_document:
    df_print: paged
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

> "Stop using Microsoft Word.  It's lame."
>
> --- Anonymous

<!-- The quote above isn't real, but is should be.  I put it there so you can see and example of a block quote text.  Oh, and this is what a comment looks like in R Markdown, you can comment out anything using the hot key ctrl+shift+c -->


The purpose of this tutorial is to explore the *Option History Practice* data set within the context of an R Markdown (`.Rmd`) file.  Along the way we will discuss iteration, flow-control, and functions in R.  

My intention is for you to interact with this document in the source window, and not necessarily for you to knit.  However, you can try knitting in order to explore the html output format.  It will be good practice for you to try to make things look pretty.

&nbsp; <!-- What does this bit of code do? -->

#### Loading Libraries

Let's start by first loading the libraries we will use for our analysis.  This is done in a *code chunk*.  You can type in code and run it either one line at a time, or the entire chunk.

**NOTE:** You don't have to `knit` an R Markdown file in order to run the code.  In fact, doing so will slow you down.  Instead, just highlight and then press `ctrl\cmd + ENTER` like you do in a `.R` script file.  You can also press `ctrl\cmd + shift + ENTER`. 

```{r, loading_libraries, collapse=TRUE}
##>library(readr)
##>library(dplyr)
```


&nbsp;

#### Reading-In Data and Viewing It

Now that we have `readr` loaded, let's read in our two options data sets.  In each of the uses of `readr::read_csv()` I added a second argument of `col_types=cols()`.  The only reason I did this was to supress annoying warning messages about.


```{r, warning=FALSE}
##>df_market_history <- read_csv("data_practice_market_history.csv", col_types=cols())
##>df_option_history <- read_csv("data_practice_option_history.csv", col_types=cols())

```


Let's get a sense for the data by using the `View()` function directly in the console. However, if you try to `knit` the document with `View()` in a code chunk, you will get an error. Why does this make sense?

```{r}
##> View(df_market_history)
##> View(df_option_history)
```


Some observations about the data:

1. Notice that `df_market_history` contains fields call `atm_volatility`, `swap_rate`, and `implied_forward`.  These are market-related measurements.  They *give you a sense for where the market is*.

1. On the other hand, `df_option_history` simply has historical prices for options.  There is no *summarizing* market data.

1. When we backtest options strategies, we will use `df_market_history` to determine which options to trade on a given day, if any.

1. We will use `df_option_history` to track the PNL of options that we trade in our strategy.



&nbsp;

#### Calculating the PNL on an Options Trade (iteration + flow-control) 


Suppose on Friday 8/13/2013, our strategy has us sell a 30-delta SPY put that expires on 9/21/2013.  Suppose our strategy involved holding this position until it expiration.  In this section we calculate the daily cummulative PNL on the trade.


First, we query `df_market_history` to find the option that we want to trade.
```{r}
##> spy_put <-
##>   df_market_history %>% 
##>   filter(underlying == "SPY") %>% 
##>   filter(expiration == as.Date("2013-09-21")) %>% 
##>   filter(trade_date == as.Date("2013-08-16")) %>% 
##>   # ^^ OTM SPY chain expiring on 9/21 as of 8/16 ^^
##>   filter(type == "put") %>% 
##>   filter(delta < 0.31) %>%
##>   # filtering for puts with a delta of less than 31
##>   top_n(1, delta)
##>   # grabbing the one with largest delta, i.e. nearest-the-money 
``` 



Let's use the cash-money notation to see what the strike and delta of `spy_put` is.
```{r}
##> spy_put$strike[1]
##> spy_put$delta[1]
```


We've isolated the option with wanted to trade on 8/16, which is the 9/21 161 SPY put.  Now we can use `df_option_history` to get the daily prices for the option from 8/16 to expiration.
```{r}
##> spy_put_history <- 
##>   df_option_history %>% 
##>   filter(underlying == "SPY") %>% 
##>   filter(expiration == as.Date("2013-09-21")) %>% 
##>   filter(type == "put") %>% 
##>   filter(strike == 161) %>% 
##>   arrange(trade_date)

##> print(spy_put_history)
```


As a simple sanity check let's make sure the bid/ask prices in `spy_put` which that we queried from `df_market_history` are the same as the bid/ask prices for 8/16 in `spy_put_hist` which we queried from `df_market_history`.
```{r}
##> spy_put$bid[1]
##> spy_put_history$bid[1]
##> spy_put$ask[1]
##> spy_put_history$ask[1]
```


Let's use `View()` to take a look at the price history of the option.
```{r}
##> View(spy_put_history)
```


Next, we will create a little data frame that we are going to use to calculate our PNL.
```{r}
##> df_pnl <- spy_put_history %>% 
##>   select(trade_date, bid, ask) %>% 
##>   mutate(daily_pnl = 0, cumm_pnl = 0)

##> View(df_pnl)
```


Now, we are going to write a for-loop to calculate the daily pnl of this option, meaning we are going to fill in `df_pnl`.  For-loops are a simple method of *iterating*: repeating a similar set of actions multiple times.  With a for-loop, you know how many times you'll need to repeat the action.

We are going to use a for-loop to fill in `df_pnl`, which we can conceptualize as iterating over a data-frame and performing the "fill-in" action repeated until we get through all the rows.
```{r}
##> for (ix_trade_date in 1:nrow(df_pnl)) {
##>   #fill in df_pnl$daily_pnl
##>   if (ix_trade_date == 1) {
##>     df_pnl$daily_pnl[ix_trade_date] <- 0
##>   }
##>   else if (ix_trade_date == 2) {
##>     df_pnl$daily_pnl[ix_trade_date] = df_pnl$bid[ix_trade_date - 1] - df_pnl$ask[ix_trade_date]  
##>   }
##>   else {
##>     df_pnl$daily_pnl[ix_trade_date] = df_pnl$ask[ix_trade_date - 1] - df_pnl$ask[ix_trade_date]
##>   }
##>   
##>   #fill in df_pnl$cumm_pnl
##>   df_pnl$cumm_pnl[ix_trade_date] = sum(df_pnl$daily_pnl[1:ix_trade_date])
##> }
##> print(df_pnl)
```


Note that this option expired out of the money, which means that the total cummulative PNL should be equal to whatever we sold the option for initially.  We can confirm this by summing `df_pnl$daily_pnl`.  And also by checking the `cumm_pnl` column.
```{r}
##> sum(df_pnl$daily_pnl)
```

**EXERCISE:** 

1. Repeat this PNL calculation for the 161 call.  Start by creating `spy_call` and `spy_call_history` and then create a PNL dataframe called `df_call_pnl` that you will fill in with a for-loop.

&nbsp;

#### Creating An Payoff Function (functions + flow-control)

We won't do a ton of function writing in this class, but it's such a central concept in R (and programming in general) that I would be remiss to not metion it.

There are a couple of situation where you may want to write a function:  

1. When you find yourself writing the same chunk of code over and over again with small variations.

2. You've written a big long sequence of code that you want to break up so it's more manigable, and it's easier to track bugs.

NOTE: some other programming languages make a distinction between functions, procedures, methods, etc.  R does not - there are only scripts and functions.


Functions can return values, or not return values.


Let's take a look at the September 2013 SPY options in `df_option_history` on their final trading day.  We will focus our attention to options that expire in the money.  Notice from this query that the `bid` and `ask` of the the option is set to payoff of the option.
```{r}
##> df_expiring_options <-
##>   df_option_history %>% 
##>     filter(underlying == "SPY") %>% 
##>     filter(expiration == as.Date("2013-09-21")) %>% 
##>     filter(trade_date == as.Date("2013-09-20")) %>% 
##>     filter(bid > 0) %>% 
##>     arrange(strike)
 
##> View(df_expiring_options)
```


What we are going to do is write a simple function that calculates the payoff of an option give the `type`, `strike`, and settle `upx` of the underlying.  Notice that once you run the `option_payoff` definition code that the function now lives in the environment.
```{r}
##> option_payoff <- function(type, strike, upx){
##>   if (type == "call"){
##>     max(upx - strike, 0)    
##>   } else if (type == "put") {
##>     max(strike - upx, 0)
##>   } else {
##>     stop("unknown option type")
##>   }
##> }

##> corp <- "call"
##> K <- 100
##> S <- 100
##> option_payoff(corp, K, S)

```


**Exercises:**

1. Use `dplyr::select()` to create a sub-dataframe from `df_expiring_options` that contains the columns `type`, `strike`, `upx`, and `bid`.  Call this sub-dataframe `df_payoffs`.

2. Use `dplyr::mutate()` to add a column to `df_payoffs` called `payoff` and initialize it's values with 0.

3. Write a for-loop to interate through `df_payoff` and fill in the `payoff` column with our function `option_payoff`. 